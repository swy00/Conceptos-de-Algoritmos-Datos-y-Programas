Realizar un programa que lea números que representan edades de personas hasta leer la edad -1. 
Finalizada la lectura se quiere informar cual fue la edad máxima leída.


Necesito una estructura que pueda ir agregando datos y 
por lo tanto su tamaño pueda ir variando en la ejecución del 
programa (estructura dinámica)

Es una colección de nodos. Cada nodo contiene un elemento 
(valor que se quiere almacenar en la lista) y una dirección de memoria 
dinámica que indica donde se  encuentra el siguiente nodo de la lista.  

Toda lista tiene un nodo inicial.

En memoria estática se declara una variable tipo PUNTERO 
(ya que son las única que pueden almacenar direcciones). 
La dirección almacenada en esa variable representa la dirección donde comienza la lista. 
Inicialmente ese puntero no contiene ninguna dirección.
Luego a medida que se quiere agregar elementos a la lista (nodo), 
se reserva una dirección de memoria dinámica y  
se carga el valor que se quiere guardar.
El último nodo de la lista indica que la dirección que le 
sigue es nil.

Cada vez que se necesite agregar un nodo se deberá reservar 
memoria dinámica (new) y cuando se quiera eliminar un nodo se debe 
liberar la memoria dinámica (dispose) .

<---------------------------------------->
Program uno;

Type 
  nombreTipo= ^nombreNodo;
     
  nombreNodo = record
       elemento: tipoElemento;
       punteroSig: nombreTipo;
  end;


Var 
  Pri: nombreTipo; 
<---------------------------------------->
LISTA DE ENTEROS
--> Program uno;

Type 
  listaE= ^nodo;
     
  nodo = record
       elemento: integer;
       punteroSig: listaE;
  end;


Var 
  Pri: listaE; 

Crear una lista quiere decir que la lista no tiene ningun elemento cargado, es decir no ocupa memoria
Al hacer new, se le asiga espacio en la memoria dinamica y por lo tanto significaria que posee algun valor

<---------------------------------------->
PROCEDIMIENTO PARA EL CREAR UNA LISTA

Program uno;

Type listaE= ^datosEnteros;
     
      datosEnteros= record
                     elem:integer;
                     sig:listaE;
                    end;
Procedure crear (var p: listaE);
begin
  p:= nil;
end;

Var 
  pri: listaE; 

Begin
  crear (pri);
End.
<---------------------------------------->
RECORRER UNA LISTA
Implica posicionarse al comienzo de la lista y a partir de allí ir 
“pasando” por cada elemento de la misma hasta llegar al final.

Inicializo una variable auxiliar con la dirección del puntero inicial de la lista

mientras (no sea el final de la lista)
   proceso el elemento (ej: imprimo, sumo, modifico)
   avanzo al siguiente elemento de auxiliar

<---------------------------------------->
procedure recorrerLista (pI: listaE);
Var
 aux:listaE; 

begin
  aux:= pI;
  while (aux^.sig <> nil) do
   begin
      write (aux^.elem);
      aux:= aux^.sig;
   end;
end;

Si la lista ingresa VACIA a este procedimiento esto no funciona, ya que el puntero de aux^.sig no existe
en la memoria dinamica
Y tampoco funciona si la lista posee UN solo elemento
Y si la lista tiene muchos elementos no imprime el último
<---------------------------------------->
FORMA CORRECTA DE ESCRIBIR EL proceso
procedure recorrerLista (pI: listaE);
Var
 aux:listaE; 

begin
  aux:= pI;
  while (aux <> nil) do
   begin
      write (aux^.elem);
      aux:= aux^.sig;
   end;
end;

En vez de mirar el aux del siguiente, me paro en el actual y veo si es NIL o no
<---------------------------------------->
ALTERNATIVA SIN USAR EL aux
procedure recorrerLista (pI: listaE);

begin
 while (pI <> nil) do
   begin
      write (pI^.elem);
      pI:= pI^.sig;
   end;
end;
<---------------------------------------->

AGREGAR ADELANTE

Implica generar un nuevo nodo y agregarlo como primer elemento de la lista. 

Para agregar siempre tengo que pedir un espacio de memoria dinamica

Implica generar un nuevo nodo y agregarlo como primer elemento de la lista. 

PASOS ---->
Reservo espacio en memoria nuevo elemento.

si (es el primer elemento a agregar)
  asigno al puntero inicial la dirección del nuevo elemento.

sino
  indico que el siguiente de nuevo elemento es el puntero inicial.
  actualizo el puntero inicial de la lista con la dirección del nuevo
  elemento.

Program uno;

Type listaE= ^datosEnteros;
     
     datosEnteros= record
                    elem:integer;
                    sig:listaE;
                   end;
Var 
  pri: listaE;
  num:integer;  {lo que se va a cargar}

Begin
  crear (pri); {pri va a pasar a valer nil }
  read (num);
  agregarAdelante (pri,num); {va a designarle una pos en memoria, y se le va a asigar el valor de num y el que le sigue será nil }
  read (num);
  agregarAdelante (pri,num); 
<---------------------------------------->
AGREGAR ADELANTE PROCESO
{pi es el puntero inicial de la list, y num el valor que quiero agregar}
procedure agregarAdelante (var pI:listaE; num:integer);
Var
 nuevo:listaE;
 
Begin
   new (nuevo);          {pido el nuevo espacio en memoria para el valor a agregar} 
   nuevo^.elem:= num;    {le cargo el valor a agregar} 
   nuevo^.sig:=nil;      {le cargo al puntero siguiente el valor nil}
   if (pI = nil) then    {Checkeo si la lista está vacia}
    pI:= nuevo           {en ese caso, el primer puntero le asigno el valor y al sig nil}
   else begin
        nuevo^.sig:= pI; {En caso de no estar vacia a mi nuevo nodo lo hago ser el pI, y el sig que era nil, será el pI original}
        pI:=nuevo;
       end;
End;

<---------------------------------------->
AGREGAR AL FINAL

Implica generar un nuevo nodo y agregarlo como último elemento de la lista. 

Pasos --->
Reservo espacio en memoria nuevo elemento.

si (es el primer elemento a agregar)
  asigno al puntero inicial la dirección del nuevo elemento.

sino
  inicializo un puntero auxiliar aux
  mientras (no llegue al último elemento)
   avanzo en la lista.
  actualizo como siguiente del último nodo al nuevo elemento
<---------------------------------------->
Program uno;

Type listaE= ^datosEnteros;
     
     datosEnteros= record
                    elem:integer;
                    sig:listaE;
                   end;
Var 
  pri: listaE;
  num:integer;  
Begin
  crear (pri);
  read (num);
  agregarAlFinal (pri,num); 
  read (num);
  agregarAlFinal (pri,num); 
<---------------------------------------->
AGREGAR AL FINAL proceso

procedure agregarAlFinal (var pI:listaE; num:integer);
Var
 nuevo,aux:listaE;  {la variable AUX me va a permitir recorrer la lista y encontrar el ultimo}
 
Begin
   new (nuevo);       {creo un nuevo espacio, le asigno el valor y al sig nil}
   nuevo^.elem:= num; 
   nuevo^.sig:=nil; 
    if (pI = nil) then {verifico si la lista es vacia}
      pI:= nuevo
    else begin          {Si no es VACIA}
      aux:= pI;         {comienzo en pI}
      while (aux ^.sig <> nil) do {mientras el sig <> nil, significa que mi lista sigue}
        aux:= aux^.sig;
      {al salir de este while, AUX queda parado en el último nodo}
      aux^.sig:=nuevo;    {aux al ser el ultimo, le asigno mi nuevo ULTIMO, el cual será [aux,nil]-->[num,nil]}   
      end;
End;
<---------------------------------------->
OPCION 2, en casos de listas muy grandes, el anterior AUX debe recorrerla toda

{voy a tener un puntero ULT, que cada vez que agrego un elemento se queda con esa direccion}
{por lo tanto al querer agregar un nuevo valor, solo tengo que asigarle el valor al ult^.sig:=nuevo}
{y luego obviamente pasar que ULT guarde esta nueva direccion}

Program uno;

Type listaE= ^datosEnteros;
     
     datosEnteros= record
                    elem:integer;
                    sig:listaE;
                   end;
Var 
  pri,ult: listaE;
  num:integer;  

Begin
  crear (pri,ult);
  read (num);
  agregarAlFinal2 (pri,ult,num); 
  read (num);
  agregarAlFinal2 (pri,,ult,num); 
<---------------------------------------->
AREGAR AL FINAL 2 proceso
procedure agregarAlFinal2 (var pI,pU:listaE; num:integer);
Var
 nuevo:listaE;
 
Begin
   new (nuevo); 
   nuevo^.elem:= num; 
   nuevo^.sig:=nil; 
    if (pI = nil) then begin
          pI:= nuevo;
          pU:= nuevo;
      end
      else begin
            pU^.sig:=nuevo;
            pU:= nuevo;       
          end;
End;

